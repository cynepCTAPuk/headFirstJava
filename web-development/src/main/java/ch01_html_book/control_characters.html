<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CtrlChar</title>
    <style>
        table, th, td { border: 1px solid blue; }
        table { border-collapse: collapse; font-family: "Trebuchet MS", sans-serif; }

        tr:hover { background-color: #ddd; }
        tr:nth-child(even) {background-color: #f2f2f2; }

        th, td { padding: 5px; }
        th { background-color: #4CAF50; color: white }
    </style>
</head>
<body>
<h3>My First JavaScript</h3>

<button type="button" onclick="document.getElementById('demo').innerHTML = Date()">
    Click me to display Date and Time.
</button>

<p id="demo"></p>

<table>
    <tr>
        <th>Символ</th>
        <th>Значение</th>
    </tr>
    <tr>
        <td>\</td>
        <td>Для обычных символов - делает их специальными. Например, выражение /s/ ищет просто символ 's'. А если
            поставить \ перед s, то /\s/ уже обозначает пробельный символ. И наоборот, если символ специальный, например
            *, то \ сделает его просто обычным символом "звездочка". Например, /a*/ ищет 0 или больше подряд идущих
            символов 'a'. Чтобы найти а со звездочкой 'a*' - поставим \ перед спец. символом: /a\*/.
        </td>
    </tr>
    <tr>
        <td>^</td>
        <td>Обозначает начало входных данных. Если установлен флаг многострочного поиска ("m"), то также сработает при
            начале новой строки.Например, /^A/ не найдет 'A' в "an A", но найдет первое 'A' в "An A."
        </td>
    </tr>
    <tr>
        <td>$</td>
        <td>Обозначает конец входных данных. Если установлен флаг многострочного поиска, то также сработает в конце
            строки.Например, /t$/ не найдет 't' в "eater", но найдет - в "eat".
        </td>
    </tr>
    <tr>
        <td>*</td>
        <td>Обозначает повторение 0 или более раз. Например, /bo*/ найдет 'boooo' в "A ghost booooed" и 'b' в "A bird
            warbled", но ничего не найдет в "A goat grunted".
        </td>
    </tr>
    <tr>
        <td>+</td>
        <td>Обозначает повторение 1 или более раз. Эквивалентно {1,}. Например, /a+/ найдет 'a' в "candy" и все 'a' в
            "caaaaaaandy".
        </td>
    <tr>
        <td>?</td>
        <td>Обозначает, что элемент может как присутствовать, так и отсутствовать. Например, /e?le?/ найдет 'el' в
            "angel" и 'le' в "angle."Если используется сразу после одного из квантификаторов *, +, ?, или {}, то задает
            "нежадный" поиск (повторение минимально возможное количество раз, до ближайшего следующего элемента
            паттерна), в противоположность "жадному" режиму по умолчанию, при котором количество повторений максимально,
            даже если следующий элемент паттерна тоже подходит.Кроме того, ? используется в предпросмотре, который
            описан в таблице под (?=), (?!), и (?: ).
        </td>
    </tr>
    <tr>
        <td>.</td>
        <td>(Десятичная точка) обозначает любой символ, кроме перевода строки: \n \r \u2028 or \u2029. (можно
            использовать [\s\S] для поиска любого символа, включая переводы строк). Например, /.n/ найдет 'an' и 'on' в
            "nay, an apple is on the tree", но не 'nay'.
        </td>
    </tr>
    <tr>
        <td>(x)</td>
        <td>Находит x и запоминает. Это называется "запоминающие скобки". Например, /(foo)/ найдет и запомнит 'foo' в
            "foo bar." Найденная подстрока хранится в массиве-результате поиска или в предопределенных свойствах объекта
            RegExp: $1, ..., $9.Кроме того, скобки объединяют то, что в них находится, в единый элемент паттерна.
            Например, (abc)* - повторение abc 0 и более раз.
        </td>
    </tr>
    <tr>
        <td>(?:x)</td>
        <td>Находит x, но не запоминает найденное. Это называется "незапоминающие скобки". Найденная подстрока не
            сохраняется в массиве результатов и свойствах RegExp.Как и все скобки, объединяют находящееся в них в единый
            подпаттерн.
        </td>
    </tr>
    <tr>
        <td>x(?=y)</td>
        <td>Находит x, только если за x следует y. Например, /Jack(?=Sprat)/ найдет 'Jack', только если за ним следует
            'Sprat'. /Jack(?=Sprat|Frost)/ найдет 'Jack', только если за ним следует 'Sprat' или 'Frost'. Однако, ни
            'Sprat' ни 'Frost' не войдут в результат поиска.
        </td>
    </tr>
    <tr>
        <td>x(?!y)</td>
        <td>Находит x, только если за x не следует y. Например, /\d+(?!\.)/ найдет число, только если за ним не следует
            десятичная точка. /\d+(?!\.)/.exec("3.141") найдет 141, но не 3.141.
        </td>
    </tr>
    <tr>
        <td>x|y</td>
        <td>Находит x или y. Например, /green|red/ найдет 'green' в "green apple" и 'red' в "red apple."</td>
    </tr>
    <tr>
        <td>{n}</td>
        <td>Где n - положительное целое число. Находит ровно n повторений предшествующего элемента. Например, /a{2}/ не
            найдет 'a' в "candy," но найдет оба a в "caandy," и первые два a в "caaandy."
        </td>
    </tr>
    <tr>
        <td>{n,}</td>
        <td>Где n - положительное целое число. Находит n и более повторений элемента. Например, /a{2,} не найдет 'a' в
            "candy", но найдет все 'a' в "caandy" и в "caaaaaaandy."
        </td>
    </tr>
    <tr>
        <td>{n,m}</td>
        <td>Где n и m - положительные целые числа. Находят от n до m повторений элемента.</td>
    <tr>
        <td>[xyz]</td>
        <td>Набор символов. Находит любой из перечисленных символов. Вы можете указать промежуток, используя тире.
            Например, [abcd] - то же самое, что [a-d]. Найдет 'b' в "brisket", а также 'a' и 'c' в "ache".
        </td>
    </tr>
    <tr>
        <td>[^xyz]</td>
        <td>Любой символ, кроме указанных в наборе. Вы также можете указать промежуток. Например, [^abc] - то же самое,
            что [^a-c]. Найдет 'r' в "brisket" и 'h' в "chop."
        </td>
    </tr>
    <tr>
        <td>[\b]</td>
        <td>Находит символ backspace. (Не путать с \b.)</td>
    </tr>
    <tr>
        <td>\b</td>
        <td>Находит границу слов (латинских), например пробел. (Не путать с [\b]). Например, /\bn\w/ найдет 'no' в
            "noonday"; /\wy\b/ найдет 'ly' в "possibly yesterday."
        </td>
    </tr>
    <tr>
        <td>\B</td>
        <td>Обозначает не границу слов. Например, /\w\Bn/ найдет 'on' в "noonday", а /y\B\w/ найдет 'ye' в "possibly
            yesterday."
        </td>
    </tr>
    <tr>
        <td>\cX</td>
        <td>Где X - буква от A до Z. Обозначает контрольный символ в строке. Например, /\cM/ обозначает символ Ctrl-M.
        </td>
    </tr>
    <tr>
        <td>\d</td>
        <td>находит цифру из любого алфавита (у нас же юникод). Испльзуйте [0-9], чтобы найти только обычные цифры.
            Например, /\d/ или /[0-9]/ найдет '2' в "B2 is the suite number."
        </td>
    </tr>
    <tr>
        <td>\D</td>
        <td>Найдет нецифровой символ (все алфавиты). [^0-9] - эквивалент для обычных цифр. Например, /\D/ или /[^0-9]/
            найдет 'B' в "B2 is the suite number."
        </td>
    </tr>
    <tr>
        <td>\f,\r,\n</td>
        <td>Соответствующие спецсимволы form-feed, line-feed, перевод строки.</td>
    </tr>
    <tr>
        <td>\s</td>
        <td>Найдет любой пробельный символ, включая пробел, табуляцию, переводы строки и другие юникодные пробельные
            символы. Например, /\s\w*/ найдет ' bar' в "foo bar."
        </td>
    </tr>
    <tr>
        <td>\S</td>
        <td>Найдет любой символ, кроме пробельного. Например, /\S\w*/ найдет 'foo' в "foo bar."</td>
    </tr>
    <tr>
        <td>\t</td>
        <td>Символ табуляции.</td>
    </tr>
    <tr>
        <td>\v</td>
        <td>Символ вертикальной табуляции.</td>
    </tr>
    <tr>
        <td>\w</td>
        <td>Найдет любой словесный (латинский алфавит) символ, включая буквы, цифры и знак подчеркивания. Эквивалентно
            [A-Za-z0-9_]. Например, /\w/ найдет 'a' в "apple," '5' в "$5.28," и '3' в "3D."
        </td>
    </tr>
    <tr>
        <td>\W</td>
        <td>Найдет любой не-(лат.)словесный символ. Эквивалентно [^A-Za-z0-9_]. Например, /\W/ и /[^$A-Za-z0-9_]/
            одинаково найдут '%' в "50%."
        </td>
    </tr>
    <tr>
        <td>\n</td>
        <td>где n - целое число. Обратная ссылка на n-ю запомненную скобками подстроку. Например, /apple(,)\sorange\1/
            найдет 'apple, orange,' в "apple, orange, cherry, peach.". За таблицей есть более полный пример.
        </td>
    </tr>
    <tr>
        <td>\0</td>
        <td>Найдет символ NUL. Не добавляйте в конец другие цифры.</td>
    </tr>
    <tr>
        <td>\xhh</td>
        <td>Найдет символ с кодом hh (2 шестнадцатиричных цифры)</td>
    </tr>
    <tr>
        <td>\uhhhh</td>
        <td>Найдет символ с кодом hhhh (4 шестнадцатиричных цифры).</td>
    </tr>
</table>
</body>
</html>