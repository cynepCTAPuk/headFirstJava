<html>
 <head></head>
 <body>
  <h2>Стек: Оптимизация&nbsp;и ключевое слово volatile</h2> 
  <h3>1 Оптимизация работы с полями класса</h3> 
  <p>Рассмотрим следующий класс:</p> 
  <pre><code>class A {

    int a = 5;

    int f() {
        return a;
    }

}</code></pre> 
  <p>Экземпляр класса А создан при помощи оператора new, и он хранится в куче.</p> 
  <p>Перед вызовом функции f&nbsp;в стек дополнительно сохраняется значение переменной a.</p> 
  <p>Во время выполнения функции&nbsp;f&nbsp;значение переменной a читается из стека и записывается в локальную переменную метода f.</p> 
  <h3>2 Запрет на оптимизацию при помощи ключевого слова&nbsp;volatile</h3> 
  <p>Рассмотрим следующий класс:</p> 
  <pre><code>class B {

    volatile int b = 5;

    int f() {
        return b;
    }

}</code></pre> 
  <p>Экземпляр класса B&nbsp;создан при помощи оператора new, и он хранится в куче.</p> 
  <p>Во время выполнения функции&nbsp;f&nbsp;значение переменной b читается напрямую&nbsp;из кучи.</p> 
  <h3>Сравнение</h3> 
  <p><em>В чем, собственно, оптимизация?</em> Ведь чтение из локальных переменных или из кучи - это всегда чтение из оперативной памяти. Дело в том, что процессоры кешируют код и локальные значения&nbsp;целыми блоками. Если процессор читает значение локальной переменной именно из кеша, то это происходит намного быстрее, чем из оперативной памяти.</p>
 </body>
</html>