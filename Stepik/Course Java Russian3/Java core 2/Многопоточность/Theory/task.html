<html>
 <head></head>
 <body>
  <h2>Многопоточность в Java</h2> 
  <h3>Основная проблематика — гонки</h3> 
  <p>Это "плавающая"&nbsp;ошибка, проявляющаяся в случайные моменты времени. Появляется она, когда два или более потока&nbsp;работают на запись с одним и тем же ресурсом. Основная задача программиста — избежать гонок.</p> 
  <h3>Пример гонки:&nbsp;инкремент переменной</h3> 
  <pre><code>volatile int count = 0;
    
    void increment() {
        count++;
    }</code></pre> 
  <p>Инкремент&nbsp;volatile переменной — это не атомарная операция. Если рассмотреть низкоуровнево, то мы можем выделить следующие атомарные операции:</p> 
  <ol> 
   <li>чтение значения из&nbsp;кучи</li> 
   <li>операция инкрементирования в процессоре</li> 
   <li>запись нового значения в кучу</li> 
  </ol> 
  <p>Допустим, в какой-то момент времени count = 5, и его одновременно читают два потока, оба увеличивают 5 на единичку&nbsp;и записывают получившуюся цифру 6 обратно в кучу. Как итог, работа одного из потоков "ушла в молоко".</p> 
  <p>В реальной жизни такое пересечение может произойти далеко не сразу, может пройти и целый год, и только тогда приложение отработает некорректно или зависнет, поэтому очень важно не допускать таких ситуаций.</p> 
  <p>При неправильном использовании многопоточности можно получить снижение производительности по сравнению с однопоточной программой.</p> 
  <h3>Средства Java</h3> 
  <p>Многопоточность в Java поддерживается с момента&nbsp;появления языка в 1995 году. Тогда еще не было многоядерных процессоров, вся многопоточность имела псевдо характер.&nbsp;</p> 
  <table border="1" cellpadding="1" cellspacing="1" style="width: 700px;"> 
   <tbody> 
    <tr> 
     <td style="width: 150px;">Ключевое слово/метод</td> 
     <td>Описание</td> 
    </tr> 
    <tr> 
     <td>wait</td> 
     <td>Метод класса Object, говорит текущему потоку, что мы пытаемся захватить данный объект; если он уже занят, переходим в ожидание.</td> 
    </tr> 
    <tr> 
     <td>notify/notifyAll</td> 
     <td>Метод класса Object, говорит, что текущий поток хочет освободить данный объект; объект может быть захвачен другим потоком.</td> 
    </tr> 
    <tr> 
     <td>synchronized</td> 
     <td> <p>Если это модификатор метода,&nbsp;говорит, что в один момент времени данный метод может работать лишь в одном потоке.</p> <p>Синхронизация происходит по экземпляру класса, где был вызван данный метод.&nbsp;Если метод статический, то синхронизация происходит по классу (по Class Definition).</p> <p>Если это блок, то используется для ручного захвата объекта.</p> </td> 
    </tr> 
    <tr> 
     <td>Thread</td> 
     <td>Класс, который может запустить отдельный поток.</td> 
    </tr> 
    <tr> 
     <td>Runnable</td> 
     <td>Интерфейс с единственным методом, этот метод является точкой входа в поток.</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>После появления&nbsp;многоядерных&nbsp;процессоров&nbsp;стало понятно, что этих инструментов явно недостаточно. Новые процессоры на уровне железа стали поддерживать некоторые атомарные операции.</p> 
  <p>Так в core появился пакет&nbsp;java.util.concurrent.*, где содержатся классы для работы с многопочностью. Их можно классифицировать следующим образом:</p> 
  <ul> 
   <li>атомики</li> 
   <li>средства синхронизации и&nbsp;блокировки</li> 
   <li>потокобезопасные коллекции</li> 
   <li>executors</li> 
   <li>Callable, Future и другое</li> 
  </ul> 
  <p>В будущих версиях Java появятся так называемые файберы (Fibers). В&nbsp;отличие&nbsp;от обычных потоков (Threads), переключение между файберами будет происходить внутри JVM без участия ОС. Это будет достигаться за счет манипуляции с программным&nbsp;стеком.</p> 
  <p>В этом уроке в основном будут рассматриваться средства из пакета Concurrent.</p>
 </body>
</html>